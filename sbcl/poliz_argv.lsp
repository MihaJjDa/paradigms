#!/usr/bin/sbcl --script

(defun abc ()
    '(#\a #\b #\c #\d #\e #\f #\g #\h #\i #\j #\k #\l #\m 
      #\n #\o #\p #\q #\r #\s #\t #\u #\v #\w #\x #\y #\z
     )
)

(defun digs () '(#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9))

(defun operations () '(#\+ #\- #\* #\/ #\%))

(defun zip (l1 l2)
    (cond ((null l1) ())
          ((null l2) ())
          (T (cons (list (car l1) (car l2)) (zip (cdr l1) (cdr l2))))
    )
)

(defun look4 (x xs)
    (cond ((null xs) (princ "ERROR: BAD PARAMETERS") "0") 
          ((equal x (caar xs)) (cadar xs))
          (T (look4 x (cdr xs)))
    )
)

(defun digs2num (l l1)
    (cond ((null l) NIL)
          ((member (car l) (digs)) (digs2num (cdr l) (cons (car l) l1)))
          (T (cons (parse-integer (coerce (reverse l1) 'string)) l))     
    )
)

(defun lst2expr (l args)
    (cond ((null l) NIL)
          ((member (car l) (abc)) 
              (lst2expr (cons (parse-integer (look4 (car l) args)) (cdr l)) args)
          )
          ((member (car l) (digs))
              (lst2expr (digs2num l ()) args)
          )
          ((equal (car l) #\ ) (lst2expr (cdr l) args))
          (T (cons (car l) (lst2expr (cdr l) args)))
    )
)

(defun numberps (l)
    (cond ((null l) T)
          ((numberp (car l)) (numberps (cdr l)))
          (T '())
    )
)

(defun calculate (l)
    (cond ((null l) '())
          ((= (length l) 1) l)
          ((= (length l) 2) l)
          ((and (equal (car l) #\+) (numberp (cadr l)) (numberp (caddr l))) 
              (calculate (cons (+ (cadr l) (caddr l)) (calculate (cdddr l)))))
          ((and (equal (car l) #\-) (numberp (cadr l)) (numberp (caddr l))) 
              (calculate (cons (- (cadr l) (caddr l)) (calculate (cdddr l)))))
          ((and (equal (car l) #\*) (numberp (cadr l)) (numberp (caddr l))) 
              (calculate (cons (* (cadr l) (caddr l)) (calculate (cdddr l)))))
          ((and (equal (car l) #\/) (numberp (cadr l)) (numberp (caddr l)))
              (cond ((equal (caddr l) 0) (princ "ERROR: ZERO DIVISION") 1)
                    (T (calculate (cons (floor (cadr l) (caddr l)) (calculate (cdddr l)))))
              )
          )
          ((and (equal (car l) #\%) (numberp (cadr l)) (numberp (caddr l)))
              (cond ((equal (caddr l) 0) (princ "ERROR: ZERO DIVISION") 1)
                    (T (calculate (cons (mod (cadr l) (caddr l)) (calculate (cdddr l)))))
              ) 
          )
          (T (cond ((numberps l) l)
                   (T (calculate (cons (car l) (calculate (cdr l)))))
             )
          )
   )
)

(defun calc (args)
   (car (calculate (lst2expr (coerce (car args) 'list) (zip (abc) (cdr args)))))
)

(print (calc (cdr *posix-argv*)))
(terpri)
